% slides.tex
\documentclass[20pt]{beamer}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}

\usetheme{default}
\usecolortheme{dove}
\useoutertheme{default}

% Slightly smaller title
\setbeamerfont{frametitle}{size=\large}
\setbeamerfont{verb}{size=\small}

% lst settings
\lstset{
    language=Haskell,
    basicstyle=\small,
    gobble=4
}

\newcommand{\vspaced}{
    \vspace{5mm}
}

\begin{document}

\title{Types and Functions}
\subtitle{An introduction to Haskell}
\author{Jasper Van der Jeugt}
\date{May 25, 2011}

\begin{frame}[plain]
    \titlepage
\end{frame}

% Introduction
% ------------

\begin{frame}{Hello!}
    My name is Jasper \\
    Student at UGent \\
    I write Haskell \\
\end{frame}

\begin{frame}[fragile]{Types}
    \begin{lstlisting}
    Int, Double, String, Bool
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Polymorphic types}
    \begin{lstlisting}
    Int, Double, String, Bool, a
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Higher-order types}
    \begin{lstlisting}
    [Int], Map Int String,
    Map Int (Set String)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Higher-order polymorphic types}
    \begin{lstlisting}
    [a], Map a String,
    Map a (Set b),
    f a, f a b
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implementation of types}
    \begin{lstlisting}
    data Maybe a = Nothing | Just a

    x :: Maybe Int
    x = Just 4

    y :: Maybe Int
    y = Nothing
    \end{lstlisting}
\end{frame}

\begin{frame}{Functions}
    Type signature \\
    Implementation
\end{frame}

\begin{frame}[fragile]{Functions: example}
    \begin{lstlisting}
    double :: Int -> Int
    double x = 2 * x

    add :: Int -> Int -> Int
    add x y = x + y
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Higher-order functions}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implicit currying}
    \begin{lstlisting}
    add :: Int -> Int -> Int
    add :: Int -> (Int -> Int)

    addTwo :: Int -> Int
    addTwo = add 2
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Higher-order functions and currying}
    \begin{lstlisting}
    doubleAll :: [Int] -> [Int]
    doubleAll = map double

    doubleAll :: [Int] -> [Int]
    doubleAll = map (* 2)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Recursive functions \& pattern matching}
    \begin{lstlisting}
    or :: [Bool] -> Bool
    or []          = False
    or (True : _)  = True
    or (False : t) = or t
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Function composition}
    \begin{lstlisting}
    compose ::
    (b -> c) -> (a -> b) -> (a -> c)
    \end{lstlisting}
    
    \vspaced
    Operator \texttt{.} is used

    \begin{equation*}
        f(g(x)) = (f \circ g)(x)
    \end{equation*}
\end{frame}

\begin{frame}[fragile]{Function composition: example}
    \begin{lstlisting}
    or :: [Bool] -> Bool
    map :: (a -> b) -> [a] -> [b]

    any :: (a -> Bool) -> [a] -> Bool
    any f = or . map f
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Function composition: example}
    \begin{lstlisting}
    any :: (a -> Bool) -> [a] -> Bool
    odd :: Bool -> Int

    any odd [2, 4, 7, 8, 10]
    \end{lstlisting}
\end{frame}

\end{document}
